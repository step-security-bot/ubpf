<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uBPF: vm/inc/ubpf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">uBPF
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_93effe02d2e8dd09437fb49d0adaddf7.html">vm</a></li><li class="navelem"><a class="el" href="dir_cf6c78462b393272f91793a3a49557d3.html">inc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ubpf.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;ubpf_config.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
</div>
<p><a href="ubpf_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7b029668bfe717c5d7b33fba3847a00f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a7b029668bfe717c5d7b33fba3847a00f">UBPF_MAX_INSTS</a>&#160;&#160;&#160;65536</td></tr>
<tr class="memdesc:a7b029668bfe717c5d7b33fba3847a00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum number of instructions that a program can contain.  <a href="ubpf_8h.html#a7b029668bfe717c5d7b33fba3847a00f">More...</a><br /></td></tr>
<tr class="separator:a7b029668bfe717c5d7b33fba3847a00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fdfd9d55e9ffcadcfe27a87340eace"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a91fdfd9d55e9ffcadcfe27a87340eace">UBPF_EBPF_STACK_SIZE</a>&#160;&#160;&#160;512</td></tr>
<tr class="memdesc:a91fdfd9d55e9ffcadcfe27a87340eace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default stack size for the eBPF program. Must be divisible by 16.  <a href="ubpf_8h.html#a91fdfd9d55e9ffcadcfe27a87340eace">More...</a><br /></td></tr>
<tr class="separator:a91fdfd9d55e9ffcadcfe27a87340eace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89d6c1d7d2bda6006e9969e731826a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#ae89d6c1d7d2bda6006e9969e731826a3">UBPF_EBPF_NONVOLATILE_SIZE</a>&#160;&#160;&#160;(sizeof(uint64_t) * 5)</td></tr>
<tr class="separator:ae89d6c1d7d2bda6006e9969e731826a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e70b5f29f0296e69a72ec5cfc588d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a23e70b5f29f0296e69a72ec5cfc588d8">UBPF_MAX_CALL_DEPTH</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:a23e70b5f29f0296e69a72ec5cfc588d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum number of nested calls in the VM.  <a href="ubpf_8h.html#a23e70b5f29f0296e69a72ec5cfc588d8">More...</a><br /></td></tr>
<tr class="separator:a23e70b5f29f0296e69a72ec5cfc588d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6334115c4408267ec35087ade6128fa0"><td class="memItemLeft" align="right" valign="top">typedef uint64_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a6334115c4408267ec35087ade6128fa0">ubpf_jit_fn</a>) (void *mem, size_t mem_len)</td></tr>
<tr class="memdesc:a6334115c4408267ec35087ade6128fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a uBPF JIT compiled function.  <a href="ubpf_8h.html#a6334115c4408267ec35087ade6128fa0">More...</a><br /></td></tr>
<tr class="separator:a6334115c4408267ec35087ade6128fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c41270d593fc7ffc2161f03f8c0b5b"><td class="memItemLeft" align="right" valign="top">typedef uint64_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a30c41270d593fc7ffc2161f03f8c0b5b">ubpf_jit_ex_fn</a>) (void *mem, size_t mem_len, uint8_t *stack, size_t stack_len)</td></tr>
<tr class="memdesc:a30c41270d593fc7ffc2161f03f8c0b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a uBPF JIT compiled function with external stack.  <a href="ubpf_8h.html#a30c41270d593fc7ffc2161f03f8c0b5b">More...</a><br /></td></tr>
<tr class="separator:a30c41270d593fc7ffc2161f03f8c0b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c06ae6f43ae6e0cbca64ac1e70bc30"><td class="memItemLeft" align="right" valign="top">typedef uint64_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a97c06ae6f43ae6e0cbca64ac1e70bc30">external_function_t</a>) (uint64_t p0, uint64_t p1, uint64_t p2, uint64_t p3, uint64_t p4)</td></tr>
<tr class="memdesc:a97c06ae6f43ae6e0cbca64ac1e70bc30"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of an external function.  <a href="ubpf_8h.html#a97c06ae6f43ae6e0cbca64ac1e70bc30">More...</a><br /></td></tr>
<tr class="separator:a97c06ae6f43ae6e0cbca64ac1e70bc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa819644ac2adf81271cf703f9eb5614b"><td class="memItemLeft" align="right" valign="top">typedef uint64_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#aa819644ac2adf81271cf703f9eb5614b">external_function_dispatcher_t</a>) (uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, unsigned int index, void *cookie)</td></tr>
<tr class="memdesc:aa819644ac2adf81271cf703f9eb5614b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of an external helper dispatcher function.  <a href="ubpf_8h.html#aa819644ac2adf81271cf703f9eb5614b">More...</a><br /></td></tr>
<tr class="separator:aa819644ac2adf81271cf703f9eb5614b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924a4a1a3e782846945d6adbabbcbb9c"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a924a4a1a3e782846945d6adbabbcbb9c">external_function_validate_t</a>) (unsigned int index, const struct ubpf_vm *vm)</td></tr>
<tr class="memdesc:a924a4a1a3e782846945d6adbabbcbb9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of an external helper validation function.  <a href="ubpf_8h.html#a924a4a1a3e782846945d6adbabbcbb9c">More...</a><br /></td></tr>
<tr class="separator:a924a4a1a3e782846945d6adbabbcbb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087420d1735791ffa6c5c436f52da00e"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a087420d1735791ffa6c5c436f52da00e">stack_usage_calculator_t</a>) (const struct ubpf_vm *vm, uint16_t pc, void *cookie)</td></tr>
<tr class="memdesc:a087420d1735791ffa6c5c436f52da00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a stack usage calculator callback function.  <a href="ubpf_8h.html#a087420d1735791ffa6c5c436f52da00e">More...</a><br /></td></tr>
<tr class="separator:a087420d1735791ffa6c5c436f52da00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fb644d080e8448c1db17bb99858391"><td class="memItemLeft" align="right" valign="top">typedef uint64_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a70fb644d080e8448c1db17bb99858391">ubpf_data_relocation</a>) (void *user_context, const uint8_t *data, uint64_t data_size, const char *symbol_name, uint64_t symbol_offset, uint64_t symbol_size)</td></tr>
<tr class="memdesc:a70fb644d080e8448c1db17bb99858391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data relocation function that is called by the VM when it encounters a R_BPF_64_64 relocation in the maps section of the ELF file.  <a href="ubpf_8h.html#a70fb644d080e8448c1db17bb99858391">More...</a><br /></td></tr>
<tr class="separator:a70fb644d080e8448c1db17bb99858391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bd2f640f675e3eeff48ea52583d699"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a64bd2f640f675e3eeff48ea52583d699">ubpf_bounds_check</a>) (void *context, uint64_t addr, uint64_t size)</td></tr>
<tr class="separator:a64bd2f640f675e3eeff48ea52583d699"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4be1055c33e64a9f81abf25f8b5ddedd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a4be1055c33e64a9f81abf25f8b5ddedd">JitMode</a> { <a class="el" href="ubpf_8h.html#a4be1055c33e64a9f81abf25f8b5ddedda81527be9d9bf3b5e45d8b59a4d1f19fd">ExtendedJitMode</a>
, <a class="el" href="ubpf_8h.html#a4be1055c33e64a9f81abf25f8b5ddedda03f63951ae56be0eb19aae34d83706f8">BasicJitMode</a>
 }</td></tr>
<tr class="memdesc:a4be1055c33e64a9f81abf25f8b5ddedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to describe JIT mode.  <a href="ubpf_8h.html#a4be1055c33e64a9f81abf25f8b5ddedd">More...</a><br /></td></tr>
<tr class="separator:a4be1055c33e64a9f81abf25f8b5ddedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a845988047e3c2fe9713e2f8a404d0751"><td class="memItemLeft" align="right" valign="top">struct ubpf_vm *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a845988047e3c2fe9713e2f8a404d0751">ubpf_create</a> (void)</td></tr>
<tr class="memdesc:a845988047e3c2fe9713e2f8a404d0751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new uBPF VM.  <a href="ubpf_8h.html#a845988047e3c2fe9713e2f8a404d0751">More...</a><br /></td></tr>
<tr class="separator:a845988047e3c2fe9713e2f8a404d0751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69dfc8e94c60e15a5db25fb6316274f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#ae69dfc8e94c60e15a5db25fb6316274f">ubpf_destroy</a> (struct ubpf_vm *vm)</td></tr>
<tr class="memdesc:ae69dfc8e94c60e15a5db25fb6316274f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a uBPF VM.  <a href="ubpf_8h.html#ae69dfc8e94c60e15a5db25fb6316274f">More...</a><br /></td></tr>
<tr class="separator:ae69dfc8e94c60e15a5db25fb6316274f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80938918080712ac0667359fd163f1a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a80938918080712ac0667359fd163f1a5">ubpf_toggle_bounds_check</a> (struct ubpf_vm *vm, bool enable)</td></tr>
<tr class="memdesc:a80938918080712ac0667359fd163f1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / disable bounds_check. Bounds check is enabled by default, but it may be too restrictive.  <a href="ubpf_8h.html#a80938918080712ac0667359fd163f1a5">More...</a><br /></td></tr>
<tr class="separator:a80938918080712ac0667359fd163f1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e25aeeb15d5dc04a58f99239c4774c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#ae7e25aeeb15d5dc04a58f99239c4774c">ubpf_set_error_print</a> (struct ubpf_vm *vm, int(*error_printf)(FILE *stream, const char *format,...))</td></tr>
<tr class="memdesc:ae7e25aeeb15d5dc04a58f99239c4774c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the function to be invoked if the program hits a fatal error.  <a href="ubpf_8h.html#ae7e25aeeb15d5dc04a58f99239c4774c">More...</a><br /></td></tr>
<tr class="separator:ae7e25aeeb15d5dc04a58f99239c4774c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53971fe3966198c6fec238d81d94bfe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ubpf_8h.html#a97c06ae6f43ae6e0cbca64ac1e70bc30">external_function_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a53971fe3966198c6fec238d81d94bfe8">as_external_function_t</a> (void *f)</td></tr>
<tr class="memdesc:a53971fe3966198c6fec238d81d94bfe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an external function to external_function_t Some external functions may not use all the parameters and, therefore, not match the external_function_t typedef. Use this for a conversion.  <a href="ubpf_8h.html#a53971fe3966198c6fec238d81d94bfe8">More...</a><br /></td></tr>
<tr class="separator:a53971fe3966198c6fec238d81d94bfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398c1c9b6d59876005eb64bbfab7b2b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a398c1c9b6d59876005eb64bbfab7b2b4">ubpf_register</a> (struct ubpf_vm *vm, unsigned int index, const char *name, <a class="el" href="ubpf_8h.html#a97c06ae6f43ae6e0cbca64ac1e70bc30">external_function_t</a> fn)</td></tr>
<tr class="memdesc:a398c1c9b6d59876005eb64bbfab7b2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an external function. The immediate field of a CALL instruction is an index into an array of functions registered by the user. This API associates a function with an index.  <a href="ubpf_8h.html#a398c1c9b6d59876005eb64bbfab7b2b4">More...</a><br /></td></tr>
<tr class="separator:a398c1c9b6d59876005eb64bbfab7b2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fbf5d30614b9c4b618209d681c3653"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a27fbf5d30614b9c4b618209d681c3653">ubpf_register_external_dispatcher</a> (struct ubpf_vm *vm, <a class="el" href="ubpf_8h.html#aa819644ac2adf81271cf703f9eb5614b">external_function_dispatcher_t</a> dispatcher, <a class="el" href="ubpf_8h.html#a924a4a1a3e782846945d6adbabbcbb9c">external_function_validate_t</a> validater)</td></tr>
<tr class="memdesc:a27fbf5d30614b9c4b618209d681c3653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a function that dispatches to external helpers The immediate field of a CALL instruction is an index of a helper function to invoke. This API sets a callback that will choose the helper function to invoke (based on the index) and then invoke it. This API also sets a callback that the validator will use to determine if a given index is a valid external function.  <a href="ubpf_8h.html#a27fbf5d30614b9c4b618209d681c3653">More...</a><br /></td></tr>
<tr class="separator:a27fbf5d30614b9c4b618209d681c3653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb195bc0c95663214fe205613ff1c9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#aacb195bc0c95663214fe205613ff1c9a">ubpf_register_stack_usage_calculator</a> (struct ubpf_vm *vm, <a class="el" href="ubpf_8h.html#a087420d1735791ffa6c5c436f52da00e">stack_usage_calculator_t</a> calculator, void *cookie)</td></tr>
<tr class="memdesc:aacb195bc0c95663214fe205613ff1c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a function that will be called during eBPF program validation to determine stack usage for a local function.  <a href="ubpf_8h.html#aacb195bc0c95663214fe205613ff1c9a">More...</a><br /></td></tr>
<tr class="separator:aacb195bc0c95663214fe205613ff1c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d32748c100c98d69dba8dcf0e9d4d0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a8d32748c100c98d69dba8dcf0e9d4d0d">ubpf_load</a> (struct ubpf_vm *vm, const void *code, uint32_t code_len, char **errmsg)</td></tr>
<tr class="memdesc:a8d32748c100c98d69dba8dcf0e9d4d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load code into a VM. This must be done before calling ubpf_exec or ubpf_compile and after registering all functions.  <a href="ubpf_8h.html#a8d32748c100c98d69dba8dcf0e9d4d0d">More...</a><br /></td></tr>
<tr class="separator:a8d32748c100c98d69dba8dcf0e9d4d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95b334d7eeb18072da3b9f4eeb66c25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#ae95b334d7eeb18072da3b9f4eeb66c25">ubpf_unload_code</a> (struct ubpf_vm *vm)</td></tr>
<tr class="memdesc:ae95b334d7eeb18072da3b9f4eeb66c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unload code from a VM.  <a href="ubpf_8h.html#ae95b334d7eeb18072da3b9f4eeb66c25">More...</a><br /></td></tr>
<tr class="separator:ae95b334d7eeb18072da3b9f4eeb66c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce3eb22d45ec43436758a139ffc8c95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a1ce3eb22d45ec43436758a139ffc8c95">ubpf_exec</a> (const struct ubpf_vm *vm, void *mem, size_t mem_len, uint64_t *bpf_return_value)</td></tr>
<tr class="memdesc:a1ce3eb22d45ec43436758a139ffc8c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a BPF program in the VM using the interpreter.  <a href="ubpf_8h.html#a1ce3eb22d45ec43436758a139ffc8c95">More...</a><br /></td></tr>
<tr class="separator:a1ce3eb22d45ec43436758a139ffc8c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ded3ae17d5879d7c19f32fa52cbbe26"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a6ded3ae17d5879d7c19f32fa52cbbe26">ubpf_exec_ex</a> (const struct ubpf_vm *vm, void *mem, size_t mem_len, uint64_t *bpf_return_value, uint8_t *stack, size_t stack_len)</td></tr>
<tr class="separator:a6ded3ae17d5879d7c19f32fa52cbbe26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b901bf6d169b6b28f818f15bd17cba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ubpf_8h.html#a6334115c4408267ec35087ade6128fa0">ubpf_jit_fn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a67b901bf6d169b6b28f818f15bd17cba">ubpf_compile</a> (struct ubpf_vm *vm, char **errmsg)</td></tr>
<tr class="memdesc:a67b901bf6d169b6b28f818f15bd17cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a BPF program in the VM to native code.  <a href="ubpf_8h.html#a67b901bf6d169b6b28f818f15bd17cba">More...</a><br /></td></tr>
<tr class="separator:a67b901bf6d169b6b28f818f15bd17cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281772f3e99c3d8505751297c51aa22e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ubpf_8h.html#a30c41270d593fc7ffc2161f03f8c0b5b">ubpf_jit_ex_fn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a281772f3e99c3d8505751297c51aa22e">ubpf_compile_ex</a> (struct ubpf_vm *vm, char **errmsg, enum <a class="el" href="ubpf_8h.html#a4be1055c33e64a9f81abf25f8b5ddedd">JitMode</a> jit_mode)</td></tr>
<tr class="memdesc:a281772f3e99c3d8505751297c51aa22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a BPF program in the VM to native code.  <a href="ubpf_8h.html#a281772f3e99c3d8505751297c51aa22e">More...</a><br /></td></tr>
<tr class="separator:a281772f3e99c3d8505751297c51aa22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2604f93223a8f076b503ba144a6b1ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ubpf_8h.html#a6334115c4408267ec35087ade6128fa0">ubpf_jit_fn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#aa2604f93223a8f076b503ba144a6b1ce">ubpf_copy_jit</a> (struct ubpf_vm *vm, void *buffer, size_t size, char **errmsg)</td></tr>
<tr class="memdesc:aa2604f93223a8f076b503ba144a6b1ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the JIT'd program code to the given buffer.  <a href="ubpf_8h.html#aa2604f93223a8f076b503ba144a6b1ce">More...</a><br /></td></tr>
<tr class="separator:aa2604f93223a8f076b503ba144a6b1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34e26c0a46366345df354ce992448c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#ab34e26c0a46366345df354ce992448c4">ubpf_translate</a> (struct ubpf_vm *vm, uint8_t *buffer, size_t *size, char **errmsg)</td></tr>
<tr class="memdesc:ab34e26c0a46366345df354ce992448c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate the eBPF byte code to machine code.  <a href="ubpf_8h.html#ab34e26c0a46366345df354ce992448c4">More...</a><br /></td></tr>
<tr class="separator:ab34e26c0a46366345df354ce992448c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2b46e62e54e7e8b81303def1014eb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#afb2b46e62e54e7e8b81303def1014eb0">ubpf_translate_ex</a> (struct ubpf_vm *vm, uint8_t *buffer, size_t *size, char **errmsg, enum <a class="el" href="ubpf_8h.html#a4be1055c33e64a9f81abf25f8b5ddedd">JitMode</a> jit_mode)</td></tr>
<tr class="memdesc:afb2b46e62e54e7e8b81303def1014eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate the eBPF byte code to machine code.  <a href="ubpf_8h.html#afb2b46e62e54e7e8b81303def1014eb0">More...</a><br /></td></tr>
<tr class="separator:afb2b46e62e54e7e8b81303def1014eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0046484ecdb72363d0c5ae710e7b96c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a0046484ecdb72363d0c5ae710e7b96c3">ubpf_set_unwind_function_index</a> (struct ubpf_vm *vm, unsigned int idx)</td></tr>
<tr class="memdesc:a0046484ecdb72363d0c5ae710e7b96c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct the uBPF runtime to apply unwind-on-success semantics to a helper function. If the function returns 0, the uBPF runtime will end execution of the eBPF program and immediately return control to the caller. This is used for implementing function like the "bpf_tail_call" helper.  <a href="ubpf_8h.html#a0046484ecdb72363d0c5ae710e7b96c3">More...</a><br /></td></tr>
<tr class="separator:a0046484ecdb72363d0c5ae710e7b96c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0990b88e11d2a0ba89fbaf8086cc0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#aeb0990b88e11d2a0ba89fbaf8086cc0f">ubpf_set_registers</a> (struct ubpf_vm *vm, uint64_t *regs)</td></tr>
<tr class="memdesc:aeb0990b88e11d2a0ba89fbaf8086cc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override the storage location for the BPF registers in the VM.  <a href="ubpf_8h.html#aeb0990b88e11d2a0ba89fbaf8086cc0f">More...</a><br /></td></tr>
<tr class="separator:aeb0990b88e11d2a0ba89fbaf8086cc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e649a921bff795712a97d3ad849f6e4"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a2e649a921bff795712a97d3ad849f6e4">ubpf_get_registers</a> (const struct ubpf_vm *vm)</td></tr>
<tr class="memdesc:a2e649a921bff795712a97d3ad849f6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the storage location for the BPF registers in the VM.  <a href="ubpf_8h.html#a2e649a921bff795712a97d3ad849f6e4">More...</a><br /></td></tr>
<tr class="separator:a2e649a921bff795712a97d3ad849f6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3257e0611c177eeaba7053e2eca92701"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a3257e0611c177eeaba7053e2eca92701">ubpf_set_pointer_secret</a> (struct ubpf_vm *vm, uint64_t secret)</td></tr>
<tr class="memdesc:a3257e0611c177eeaba7053e2eca92701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional secret to improve ROP protection.  <a href="ubpf_8h.html#a3257e0611c177eeaba7053e2eca92701">More...</a><br /></td></tr>
<tr class="separator:a3257e0611c177eeaba7053e2eca92701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce8c1133902da4629c53aa82c159611"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a6ce8c1133902da4629c53aa82c159611">ubpf_register_data_relocation</a> (struct ubpf_vm *vm, void *user_context, <a class="el" href="ubpf_8h.html#a70fb644d080e8448c1db17bb99858391">ubpf_data_relocation</a> relocation)</td></tr>
<tr class="memdesc:a6ce8c1133902da4629c53aa82c159611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a relocation function for the VM.  <a href="ubpf_8h.html#a6ce8c1133902da4629c53aa82c159611">More...</a><br /></td></tr>
<tr class="separator:a6ce8c1133902da4629c53aa82c159611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286aa9da7688d1327756e967eafc2f03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a286aa9da7688d1327756e967eafc2f03">ubpf_register_data_bounds_check</a> (struct ubpf_vm *vm, void *user_context, <a class="el" href="ubpf_8h.html#a64bd2f640f675e3eeff48ea52583d699">ubpf_bounds_check</a> bounds_check)</td></tr>
<tr class="memdesc:a286aa9da7688d1327756e967eafc2f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a bounds check function for the VM.  <a href="ubpf_8h.html#a286aa9da7688d1327756e967eafc2f03">More...</a><br /></td></tr>
<tr class="separator:a286aa9da7688d1327756e967eafc2f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cdff7433769540c61a1cf41a0c241a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a96cdff7433769540c61a1cf41a0c241a">ubpf_set_jit_code_size</a> (struct ubpf_vm *vm, size_t code_size)</td></tr>
<tr class="memdesc:a96cdff7433769540c61a1cf41a0c241a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a size for the buffer allocated to machine code generated during JIT compilation. The JIT compiler allocates a buffer to store the code while it is being generated. The default may be too big for some embedded platforms. Use this to customize the size of that buffer. Note: The buffer being sized here is <em>not</em> the final location of the machine code returned by ubpf_compile &ndash; that buffer is perfectly sized to match the size of the generated machine code.  <a href="ubpf_8h.html#a96cdff7433769540c61a1cf41a0c241a">More...</a><br /></td></tr>
<tr class="separator:a96cdff7433769540c61a1cf41a0c241a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfaef65d4add64487f09c0bd1d0a08df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#adfaef65d4add64487f09c0bd1d0a08df">ubpf_set_instruction_limit</a> (struct ubpf_vm *vm, uint32_t limit, uint32_t *previous_limit)</td></tr>
<tr class="memdesc:adfaef65d4add64487f09c0bd1d0a08df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the instruction limit for the VM. This is the maximum number of instructions that a program may execute during a call to ubpf_exec. It has no effect on JIT'd programs.  <a href="ubpf_8h.html#adfaef65d4add64487f09c0bd1d0a08df">More...</a><br /></td></tr>
<tr class="separator:adfaef65d4add64487f09c0bd1d0a08df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ae89d6c1d7d2bda6006e9969e731826a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89d6c1d7d2bda6006e9969e731826a3">&#9670;&nbsp;</a></span>UBPF_EBPF_NONVOLATILE_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UBPF_EBPF_NONVOLATILE_SIZE&#160;&#160;&#160;(sizeof(uint64_t) * 5)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91fdfd9d55e9ffcadcfe27a87340eace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91fdfd9d55e9ffcadcfe27a87340eace">&#9670;&nbsp;</a></span>UBPF_EBPF_STACK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UBPF_EBPF_STACK_SIZE&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default stack size for the eBPF program. Must be divisible by 16. </p>

</div>
</div>
<a id="a23e70b5f29f0296e69a72ec5cfc588d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e70b5f29f0296e69a72ec5cfc588d8">&#9670;&nbsp;</a></span>UBPF_MAX_CALL_DEPTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UBPF_MAX_CALL_DEPTH&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default maximum number of nested calls in the VM. </p>

</div>
</div>
<a id="a7b029668bfe717c5d7b33fba3847a00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b029668bfe717c5d7b33fba3847a00f">&#9670;&nbsp;</a></span>UBPF_MAX_INSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UBPF_MAX_INSTS&#160;&#160;&#160;65536</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default maximum number of instructions that a program can contain. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa819644ac2adf81271cf703f9eb5614b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa819644ac2adf81271cf703f9eb5614b">&#9670;&nbsp;</a></span>external_function_dispatcher_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t(* external_function_dispatcher_t) (uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, unsigned int index, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of an external helper dispatcher function. </p>

</div>
</div>
<a id="a97c06ae6f43ae6e0cbca64ac1e70bc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c06ae6f43ae6e0cbca64ac1e70bc30">&#9670;&nbsp;</a></span>external_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t(* external_function_t) (uint64_t p0, uint64_t p1, uint64_t p2, uint64_t p3, uint64_t p4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of an external function. </p>

</div>
</div>
<a id="a924a4a1a3e782846945d6adbabbcbb9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924a4a1a3e782846945d6adbabbcbb9c">&#9670;&nbsp;</a></span>external_function_validate_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* external_function_validate_t) (unsigned int index, const struct ubpf_vm *vm)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of an external helper validation function. </p>

</div>
</div>
<a id="a087420d1735791ffa6c5c436f52da00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087420d1735791ffa6c5c436f52da00e">&#9670;&nbsp;</a></span>stack_usage_calculator_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* stack_usage_calculator_t) (const struct ubpf_vm *vm, uint16_t pc, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a stack usage calculator callback function. </p>
<p>See ubpf_register_stack_usage_calculator for additional information. </p>

</div>
</div>
<a id="a64bd2f640f675e3eeff48ea52583d699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bd2f640f675e3eeff48ea52583d699">&#9670;&nbsp;</a></span>ubpf_bounds_check</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* ubpf_bounds_check) (void *context, uint64_t addr, uint64_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70fb644d080e8448c1db17bb99858391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fb644d080e8448c1db17bb99858391">&#9670;&nbsp;</a></span>ubpf_data_relocation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t(* ubpf_data_relocation) (void *user_context, const uint8_t *data, uint64_t data_size, const char *symbol_name, uint64_t symbol_offset, uint64_t symbol_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data relocation function that is called by the VM when it encounters a R_BPF_64_64 relocation in the maps section of the ELF file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user_context</td><td>The user context that was passed to ubpf_register_data_relocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to start of the map section. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of the map section. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol_name</td><td>Name of the symbol that is referenced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol_offset</td><td>Offset of the symbol relative to the start of the map section. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol_size</td><td>Size of the symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint64_t The value to insert into the BPF program. </dd></dl>

</div>
</div>
<a id="a30c41270d593fc7ffc2161f03f8c0b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c41270d593fc7ffc2161f03f8c0b5b">&#9670;&nbsp;</a></span>ubpf_jit_ex_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t(* ubpf_jit_ex_fn) (void *mem, size_t mem_len, uint8_t *stack, size_t stack_len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque type for a uBPF JIT compiled function with external stack. </p>

</div>
</div>
<a id="a6334115c4408267ec35087ade6128fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6334115c4408267ec35087ade6128fa0">&#9670;&nbsp;</a></span>ubpf_jit_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t(* ubpf_jit_fn) (void *mem, size_t mem_len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque type for a uBPF JIT compiled function. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a4be1055c33e64a9f81abf25f8b5ddedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be1055c33e64a9f81abf25f8b5ddedd">&#9670;&nbsp;</a></span>JitMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ubpf_8h.html#a4be1055c33e64a9f81abf25f8b5ddedd">JitMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to describe JIT mode. </p>
<p>ExtendedJitMode specifies that an invocation of that code have 4 parameters:</p><ol type="1">
<li>A pointer to the program's memory space.</li>
<li>The size of the program's memory space.</li>
<li>A pointer to memory to be used by the program as a stack during execution.</li>
<li>The size of the provided stack space. See ubpf_jit_ex_fn for more information.</li>
</ol>
<p>BasicJitMode specifies that an invocation of that code have 2 parameters:</p><ol type="1">
<li>A pointer to the program's memory space.</li>
<li>The size of the program's memory space. The function generated by the JITer executing in basic mode automatically allocates a stack for the program's execution. See ubpf_jit_fn for more information. </li>
</ol>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4be1055c33e64a9f81abf25f8b5ddedda81527be9d9bf3b5e45d8b59a4d1f19fd"></a>ExtendedJitMode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4be1055c33e64a9f81abf25f8b5ddedda03f63951ae56be0eb19aae34d83706f8"></a>BasicJitMode&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a53971fe3966198c6fec238d81d94bfe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53971fe3966198c6fec238d81d94bfe8">&#9670;&nbsp;</a></span>as_external_function_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ubpf_8h.html#a97c06ae6f43ae6e0cbca64ac1e70bc30">external_function_t</a> as_external_function_t </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast an external function to external_function_t Some external functions may not use all the parameters and, therefore, not match the external_function_t typedef. Use this for a conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The function to cast to match the signature of an external function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>external function, as external_function_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67b901bf6d169b6b28f818f15bd17cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b901bf6d169b6b28f818f15bd17cba">&#9670;&nbsp;</a></span>ubpf_compile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ubpf_8h.html#a6334115c4408267ec35087ade6128fa0">ubpf_jit_fn</a> ubpf_compile </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>errmsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile a BPF program in the VM to native code. </p>
<p>A program must be loaded into the VM and all external functions (or the external helper dispatcher) must be registered before calling this function.</p>
<p>The JITer executes in basic mode when invoked through this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to compile the program in. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errmsg</td><td>The error message, if any. This should be freed by the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ubpf_jit_fn A pointer to the compiled program, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a281772f3e99c3d8505751297c51aa22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281772f3e99c3d8505751297c51aa22e">&#9670;&nbsp;</a></span>ubpf_compile_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ubpf_8h.html#a30c41270d593fc7ffc2161f03f8c0b5b">ubpf_jit_ex_fn</a> ubpf_compile_ex </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>errmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="ubpf_8h.html#a4be1055c33e64a9f81abf25f8b5ddedd">JitMode</a>&#160;</td>
          <td class="paramname"><em>jit_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile a BPF program in the VM to native code. </p>
<p>A program must be loaded into the VM and all external functions (or the external helper dispatcher) must be registered before calling this function.</p>
<p>The JITer executes in the prescribed mode when invoked through this function. If jit_mode is basic, the caller will have to cast the function pointer to the appropriate type (ubpf_jit_fn).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to compile the program in. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errmsg</td><td>The error message, if any. This should be freed by the caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jit_mode</td><td>The mode in which to execute the JITer &ndash; basic or extended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ubpf_jit_fn A pointer to the compiled program, or NULL on failure. </dd></dl>

</div>
</div>
<a id="aa2604f93223a8f076b503ba144a6b1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2604f93223a8f076b503ba144a6b1ce">&#9670;&nbsp;</a></span>ubpf_copy_jit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ubpf_8h.html#a6334115c4408267ec35087ade6128fa0">ubpf_jit_fn</a> ubpf_copy_jit </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>errmsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the JIT'd program code to the given buffer. </p>
<p>A program must have been loaded into the VM and already JIT'd before calling this function.</p>
<p>Note: Caller must know the mode in which the JITer was executed and may need to cast the result to the appropriate type (e.g., ubpf_jit_ex_fn).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM of the already JIT'd program. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errmsg</td><td>The error message, if any. This should be freed by the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ubpf_jit_fn A pointer to the compiled program (the same as buffer), or NULL on failure. </dd></dl>

</div>
</div>
<a id="a845988047e3c2fe9713e2f8a404d0751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845988047e3c2fe9713e2f8a404d0751">&#9670;&nbsp;</a></span>ubpf_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ubpf_vm* ubpf_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new uBPF VM. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new VM, or NULL on failure. </dd></dl>

</div>
</div>
<a id="ae69dfc8e94c60e15a5db25fb6316274f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69dfc8e94c60e15a5db25fb6316274f">&#9670;&nbsp;</a></span>ubpf_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubpf_destroy </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a uBPF VM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ce3eb22d45ec43436758a139ffc8c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce3eb22d45ec43436758a139ffc8c95">&#9670;&nbsp;</a></span>ubpf_exec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_exec </td>
          <td>(</td>
          <td class="paramtype">const struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mem_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>bpf_return_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a BPF program in the VM using the interpreter. </p>
<p>A program must be loaded into the VM and all external functions must be registered before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to execute the program in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mem</td><td>The memory to pass to the program. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_len</td><td>The length of the memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bpf_return_value</td><td>The value of the r0 register when the program exits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ded3ae17d5879d7c19f32fa52cbbe26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ded3ae17d5879d7c19f32fa52cbbe26">&#9670;&nbsp;</a></span>ubpf_exec_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_exec_ex </td>
          <td>(</td>
          <td class="paramtype">const struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mem_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>bpf_return_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stack_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e649a921bff795712a97d3ad849f6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e649a921bff795712a97d3ad849f6e4">&#9670;&nbsp;</a></span>ubpf_get_registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* ubpf_get_registers </td>
          <td>(</td>
          <td class="paramtype">const struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the storage location for the BPF registers in the VM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to get the register storage from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint64_t* A pointer to the register storage. </dd></dl>

</div>
</div>
<a id="a8d32748c100c98d69dba8dcf0e9d4d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d32748c100c98d69dba8dcf0e9d4d0d">&#9670;&nbsp;</a></span>ubpf_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_load </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>code_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>errmsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load code into a VM. This must be done before calling ubpf_exec or ubpf_compile and after registering all functions. </p>
<p>'code' should point to eBPF bytecodes and 'code_len' should be the size in bytes of that buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to load the code into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>The eBPF bytecodes to load. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code_len</td><td>The length of the eBPF bytecodes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errmsg</td><td>The error message, if any. This should be freed by the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a398c1c9b6d59876005eb64bbfab7b2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398c1c9b6d59876005eb64bbfab7b2b4">&#9670;&nbsp;</a></span>ubpf_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_register </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ubpf_8h.html#a97c06ae6f43ae6e0cbca64ac1e70bc30">external_function_t</a>&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an external function. The immediate field of a CALL instruction is an index into an array of functions registered by the user. This API associates a function with an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to register the function on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index to register the function at. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The human readable name of the function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>The function to register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a286aa9da7688d1327756e967eafc2f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286aa9da7688d1327756e967eafc2f03">&#9670;&nbsp;</a></span>ubpf_register_data_bounds_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_register_data_bounds_check </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ubpf_8h.html#a64bd2f640f675e3eeff48ea52583d699">ubpf_bounds_check</a>&#160;</td>
          <td class="paramname"><em>bounds_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a bounds check function for the VM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to set the bounds check function for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_context</td><td>The user context to pass to the bounds check function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bounds_check</td><td>The bounds check function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ce8c1133902da4629c53aa82c159611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce8c1133902da4629c53aa82c159611">&#9670;&nbsp;</a></span>ubpf_register_data_relocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_register_data_relocation </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ubpf_8h.html#a70fb644d080e8448c1db17bb99858391">ubpf_data_relocation</a>&#160;</td>
          <td class="paramname"><em>relocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a relocation function for the VM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to set the relocation function for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relocation</td><td>The relocation function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The value to insert into the BPF program. </dd></dl>

</div>
</div>
<a id="a27fbf5d30614b9c4b618209d681c3653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27fbf5d30614b9c4b618209d681c3653">&#9670;&nbsp;</a></span>ubpf_register_external_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_register_external_dispatcher </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ubpf_8h.html#aa819644ac2adf81271cf703f9eb5614b">external_function_dispatcher_t</a>&#160;</td>
          <td class="paramname"><em>dispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ubpf_8h.html#a924a4a1a3e782846945d6adbabbcbb9c">external_function_validate_t</a>&#160;</td>
          <td class="paramname"><em>validater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a function that dispatches to external helpers The immediate field of a CALL instruction is an index of a helper function to invoke. This API sets a callback that will choose the helper function to invoke (based on the index) and then invoke it. This API also sets a callback that the validator will use to determine if a given index is a valid external function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to register the function on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dispatcher</td><td>The callback that will dispatch to the external helper. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">validater</td><td>The callback that will validate that a given index is valid for an external helper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacb195bc0c95663214fe205613ff1c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb195bc0c95663214fe205613ff1c9a">&#9670;&nbsp;</a></span>ubpf_register_stack_usage_calculator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_register_stack_usage_calculator </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ubpf_8h.html#a087420d1735791ffa6c5c436f52da00e">stack_usage_calculator_t</a>&#160;</td>
          <td class="paramname"><em>calculator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a function that will be called during eBPF program validation to determine stack usage for a local function. </p>
<p>In eBPF, the frame pointer is a read-only register. Therefore, the eBPF interpreter or the eBPF JITer need to know the stack usage for each local function so that the frame pointer can be adjusted properly on behalf of the calling function. The callback registered here has access to a cookie for context (specified in the call to this function), the PC (in the eBPF program) of the first instruction of a local function and the <code>ubpf_vm</code>.</p>
<p>The callback's job is to calculate the amount of stack space used by the local function that starts at the given PC.</p>
<p>If the callback returns 0 or there is no callback registered, the eBPF interpreter/JITer assume that the local function uses the maximum stack available according to the spec (512K).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to register the callback with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dispatcher</td><td>The callback that will be invoked to determine the amount of stack usage for a local function that starts at ... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pc</td><td>The pc of the function whose stack usage the callback must caculate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7e25aeeb15d5dc04a58f99239c4774c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e25aeeb15d5dc04a58f99239c4774c">&#9670;&nbsp;</a></span>ubpf_set_error_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubpf_set_error_print </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(FILE *stream, const char *format,...)&#160;</td>
          <td class="paramname"><em>error_printf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the function to be invoked if the program hits a fatal error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to set the error function on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_printf</td><td>The function to be invoked on fatal error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfaef65d4add64487f09c0bd1d0a08df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfaef65d4add64487f09c0bd1d0a08df">&#9670;&nbsp;</a></span>ubpf_set_instruction_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_set_instruction_limit </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>previous_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the instruction limit for the VM. This is the maximum number of instructions that a program may execute during a call to ubpf_exec. It has no effect on JIT'd programs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to set the instruction limit for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit</td><td>The maximum number of instructions that a program may execute or 0 for no limit. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">previous_limit</td><td>Optional pointer to store the previous instruction limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Success. </dd>
<dd>
-1 Failure. </dd></dl>

</div>
</div>
<a id="a96cdff7433769540c61a1cf41a0c241a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cdff7433769540c61a1cf41a0c241a">&#9670;&nbsp;</a></span>ubpf_set_jit_code_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_set_jit_code_size </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>code_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a size for the buffer allocated to machine code generated during JIT compilation. The JIT compiler allocates a buffer to store the code while it is being generated. The default may be too big for some embedded platforms. Use this to customize the size of that buffer. Note: The buffer being sized here is <em>not</em> the final location of the machine code returned by ubpf_compile &ndash; that buffer is perfectly sized to match the size of the generated machine code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to set the buffer size for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code_size</td><td>The size of the buffer to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3257e0611c177eeaba7053e2eca92701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3257e0611c177eeaba7053e2eca92701">&#9670;&nbsp;</a></span>ubpf_set_pointer_secret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_set_pointer_secret </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>secret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional secret to improve ROP protection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to set the secret for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secret</td><td>Optional secret to improve ROP protection. Returns 0 on success, -1 on error (e.g. if the secret is set after the instructions are loaded). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb0990b88e11d2a0ba89fbaf8086cc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0990b88e11d2a0ba89fbaf8086cc0f">&#9670;&nbsp;</a></span>ubpf_set_registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubpf_set_registers </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>regs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override the storage location for the BPF registers in the VM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to set the register storage in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regs</td><td>The register storage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0046484ecdb72363d0c5ae710e7b96c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0046484ecdb72363d0c5ae710e7b96c3">&#9670;&nbsp;</a></span>ubpf_set_unwind_function_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_set_unwind_function_index </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instruct the uBPF runtime to apply unwind-on-success semantics to a helper function. If the function returns 0, the uBPF runtime will end execution of the eBPF program and immediately return control to the caller. This is used for implementing function like the "bpf_tail_call" helper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to set the unwind helper in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index of the helper function to unwind on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80938918080712ac0667359fd163f1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80938918080712ac0667359fd163f1a5">&#9670;&nbsp;</a></span>ubpf_toggle_bounds_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ubpf_toggle_bounds_check </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable / disable bounds_check. Bounds check is enabled by default, but it may be too restrictive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to enable / disable bounds check on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>Enable bounds check if true, disable if false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Bounds check was previously enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab34e26c0a46366345df354ce992448c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34e26c0a46366345df354ce992448c4">&#9670;&nbsp;</a></span>ubpf_translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_translate </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>errmsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate the eBPF byte code to machine code. </p>
<p>A program must be loaded into the VM and all external functions must be registered before calling this function.</p>
<p>The JITer executes in basic mode when invoked through this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to translate the program in. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer to store the translated code in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errmsg</td><td>The error message, if any. This should be freed by the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb2b46e62e54e7e8b81303def1014eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2b46e62e54e7e8b81303def1014eb0">&#9670;&nbsp;</a></span>ubpf_translate_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_translate_ex </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>errmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="ubpf_8h.html#a4be1055c33e64a9f81abf25f8b5ddedd">JitMode</a>&#160;</td>
          <td class="paramname"><em>jit_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate the eBPF byte code to machine code. </p>
<p>A program must be loaded into the VM and all external functions must be registered before calling this function.</p>
<p>The JITer executes in the prescribed mode when invoked through this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to translate the program in. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer to store the translated code in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errmsg</td><td>The error message, if any. This should be freed by the caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jit_mode</td><td>The mode in which to execute the JITer &ndash; basic or extended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae95b334d7eeb18072da3b9f4eeb66c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95b334d7eeb18072da3b9f4eeb66c25">&#9670;&nbsp;</a></span>ubpf_unload_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubpf_unload_code </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unload code from a VM. </p>
<p>The VM must be reloaded with code before calling ubpf_exec or ubpf_compile.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to unload the code from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
